<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Agile | ジタバタしばた]]></title>
  <link href="http://uryyyyyyy.shake-freek.com/blog/categories/agile/atom.xml" rel="self"/>
  <link href="http://uryyyyyyy.shake-freek.com/"/>
  <updated>2016-03-16T01:11:30+09:00</updated>
  <id>http://uryyyyyyy.shake-freek.com/</id>
  <author>
    <name><![CDATA[しばたこ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[アジャイルサムライ]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2015/11/20/agile-samurai/"/>
    <updated>2015-11-20T23:47:36+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2015/11/20/agile-samurai</id>
    <content type="html"><![CDATA[<p>ソフトウェア開発において、アジャイル開発は王道（というかソフトウェア以外ではしたくても出来なかった手法）だと理解しています。
その手法について良くまとめられていると評判だった本書を読んで、個人的なポイントをメモしてみました。</p>

<!--more-->

<p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4274068560/jitabatashiba-22/" target="_blank"><img src="http://ecx.images-amazon.com/images/I/51b4P511wTL.jpg" width="350" height="500" alt="アジャイルサムライ−達人開発者への道−" title="アジャイルサムライ−達人開発者への道−" /></a></p>

<h2 id="section">概要</h2>

<p>一番大切なことは、常に顧客に価値をもたらすこと。つまりは定期的（一週間毎くらい）に、動く（テスト済みの）ソフトウェアを提供すること。
仕様書や計画書はその補完にしか過ぎない。実際にメリットを提供できて初めて責任を果たしたと言える。</p>

<p>そのために以下を心がける。</p>

<ul>
  <li>大きな問題、ストーリーは小さく分割する。
    <ul>
      <li>大きすぎると期間・仕様が見積もれない。いざ完成してからズレていたと発覚しては遅い。</li>
    </ul>
  </li>
  <li>本当にメリットのあるもののみに注力し、他は忘れる。
    <ul>
      <li>システムのうち、お客様にメリットを提供している機能はごく一部だから。</li>
    </ul>
  </li>
  <li>常に動く状態にする。
    <ul>
      <li>いつでもテスト可能なようにすることで、仕様を満たしていることを保証する。</li>
    </ul>
  </li>
  <li>フィードバック、実挙動の確認を求める。
    <ul>
      <li>仕様を知っていてお金を出すのはお客様なのだから。</li>
    </ul>
  </li>
  <li>必要とあれば方針を変える
    <ul>
      <li>定期的に（イテレーション毎に）顧客と話して機能の優先度、仕様を確認する。なぜなら、仕様もスケジュールも常に流動するから。</li>
    </ul>
  </li>
  <li>説明責任を果たす。
    <ul>
      <li>毎週成果を求められ、また顧客と共に次の計画を考えるため、全てを説明して納得してもらわなければならない。</li>
    </ul>
  </li>
</ul>

<p>しかし、ウォーターフォール型で最後に神頼みをするよりマシかもしれない。</p>

<h3 id="agileagile">なぜagileか。Agileとは何か</h3>

<p>Agileとは、ウォーターフォールと比較して、最初に要件を固めすぎずに都度対応していく方法のこと。
これによって、</p>

<ul>
  <li>早いうちからユーザーにシステムを使ってもらうことで価値を提供できる。</li>
  <li>着実に目に見える形で進捗を重ねることができる。</li>
  <li>急なスケジュール・仕様変更に強くなる。</li>
</ul>

<p>特に最後の部分で、ソフトウェア開発においては以下の経験則が成り立つことを前提としている。</p>

<ul>
  <li>プロジェクトの開始時点に全ての要求をヒアリングできない。</li>
  <li>要求は必ず後で変更される。</li>
  <li>納期や資金に比べて、やるべきことは常に多すぎる</li>
</ul>

<p>ただ、これはハードウェアの世界でもおそらく起きているものの、顧客側が仕方ないと理解しているため問題とならないのではと個人的に推測する。</p>

<h2 id="section-1">登場人物</h2>

<h3 id="section-2">要件は誰が決める？</h3>

<p>ソフトウェアの要件とは、どんな価値を提供するかに当たる。つまりは顧客（あるいはそのドメインの専門家）しか知ることはない。
どの機能がどのくらいの優先度で必要なのか、もしQCD全てをこなすことが難しければ、どの部分で妥協できるのか、などを決める。
ということは、ソフトウェア開発においては顧客も積極的に参加しなくてはいけない。常に要件を発言し、システムのフィードバックを行うことが必要だ。</p>

<p>もしこれらの作業を引き受けてくれる人がいない場合は、まだそのプロジェクト自体の優先度が高くないのかもしれない。他の事に目を向けよう。</p>

<h3 id="section-3">誰が作る？</h3>

<p>開発チームは、テスター、プログラマ、デザイナ、アナリストなどの全ての役割を誰かが担うことになる。
それぞれの役割は明確に区切られているものではないため、スピードを求めると同じ人が複数の責務を担うことが重要になる。要するに、ある程度の専門性を持ちつつ、必要に応じて他の分野の作業も担えるゼネラリストが求められる。</p>

<p>代表的な役割を順番に見ていく。</p>

<h4 id="section-4">アナリスト</h4>

<p>顧客と開発チームの橋渡しを行う。</p>

<ul>
  <li>顧客の要求をヒアリングしてシステムの要件に落としこむ。</li>
  <li>優先度を定義する。</li>
  <li>システムの完了を確認するためのシナリオを用意する。</li>
</ul>

<p>などを担う。</p>

<h4 id="section-5">プログラマ</h4>

<ul>
  <li>要件のコストを見積もる。</li>
  <li>要件を機械語に翻訳する。</li>
  <li>技術選定を行う。</li>
  <li>実装のゴールを定義するテストを作成する。</li>
</ul>

<h4 id="section-6">テスター</h4>

<ul>
  <li>非機能要件（性能、セキュリティ、コスト）のテスト設計を行う。</li>
  <li>テスト作成を手伝う。</li>
  <li>テストを自動化し常に回せるようにする。</li>
</ul>

<h4 id="section-7">プロジェクトマネージャ</h4>

<ul>
  <li>プロジェクトの様子（進捗・タスク）を確認し共有する。</li>
  <li>プロジェクトの環境を整える（開発環境・工数確保）</li>
</ul>

<h4 id="section-8">デザイナ</h4>

<ul>
  <li>よりユーザーが使いやすいUIを考案、実装する。</li>
  <li>ユーザーのニーズを深堀りしてシステムに落としこむ。</li>
</ul>

<h4 id="section-9">ステークホルダーは他も居る</h4>

<p>組織の中でプロジェクトを行っている場合、利害関係者はプロジェクトメンバーだけでない。品質管理の部門やセキュリティ、インフラ部門なども関わるかもしれない。
メンバーだけで突き進むのではなく、彼らのことも気に留めて、時には情報共有をしておく必要がある。</p>

<h2 id="section-10">プロジェクトの進め方</h2>

<h3 id="section-11">目指す方向を共有する</h3>

<p>インセプションデッキと呼ばれるツールを使った例を挙げる。</p>

<h4 id="section-12">チームの目的は何か？</h4>

<p>まずはチームとして集まった目的、作るシステムの概要を確認する。このとき、2,3センテンスでまとめられるレベルまで落としこみ、かつそれが魅力的（顧客がお金を払ってでも欲しがる）であるかどうかを確認する。
もしそこまで落とし込めなければプロジェクトを止めることも有り。</p>

<h4 id="section-13">何をやらないか？</h4>

<p>プロジェクトメンバー、お客様への情報共有としてわかりやすい例。これによって、本当にフォーカスする問題が浮かび上がる。
ただし、まだどうするか決まってないことはやらないことではなく未定とする。</p>

<h4 id="section-14">期間・予算はどのくらいか？実現可能なラインか？</h4>

<p>大まかな要求が決まったら、実現プランを考えていく。（例えばWebアプリを作るとか、データベースはこんな感じにするとか）
ここでは具体的なものではなく、チームや顧客への大まかな道筋の共有ができれば良い。どうせ後で要求も実装も変わってくるから。</p>

<p>また、プロジェクトを進める前に考えられるリスクを先に洗い出しておき、大まかな対策を考える。ここで案を考えておくことで、プロジェクトがひっくり返るリスクを減らしておくことに繋がる。（リスクの起こる確率が大きく、かつ対応不可能であれば、それはプロジェクト自体の筋が悪いのかもしれない。）
もちろん、天災などどうしようもないものは考えるだけ無駄だけど。</p>

<p>そうしてプロジェクトを進めても問題なさそうと推測できるようになったら、最後に大まかにスケジュールとコスト感を見積もる。これはコミットではないが、顧客にとって必要な情報だからだ。
このとき、プロジェクトの規模が大きすぎるときは最長半年くらいで小ゴールを引いておく。そうしないと見積りできなり、顧客もGoの判断を下すことのリスクが大きすぎるから。</p>

<h4 id="section-15">何を妥協できるか？</h4>

<p>往々にしてプロジェクトはスケジュールよりも悪い方向にズレる。
その時になってから妥協案を考えると、顧客に不快感を与えてしまったり、急なことで決断が出来なくなる恐れがある。
そこで事前に妥協できるポイントを聞いておく。</p>

<p>フィーチャのいくつかを削るとか、期日を延ばすとかが典型的な例。
なぜなら、</p>

<ul>
  <li>予算は調整が難しく、またソフトウェアにおいてはお金は万能ではないから。</li>
  <li>品質は、下げたからといって機能が追加できるものではなく、むしろお互いに余計な時間を取られることに繋がりかねないから。</li>
</ul>

<h3 id="section-16">計画を立てる</h3>

<p>まず、計画と実装プランは異なる。最初に大まかな見積もりと優先度でもってイテレーションの計画を立て、その時期が来てから詳細設計と実装案を考える。最初に詳細設計までしない理由は、後で変更される可能性が高いため。</p>

<p>何度も記述されているが、大事なことは「要求は顧客が知っているので、もっと対話を増やすこと」。それによって計画すべきシナリオが明確になる。</p>

<h4 id="section-17">ユーザーストーリーを聞く</h4>

<p>ここでは顧客がシステムに求める機能を簡単にまとめる。これによって、工数の概算やスケジュール感、顧客の要求が共有される。
詳細な仕様や実装案は時期が来たら再度検討するので、ここではキーワードを書き留めて置くことが重要。（技術寄りの実装案などはここでは考えなくて良い。早すぎる最適化になるから。）
もちろん、何が達成できればそのストーリーの実装を終えたと判断できるか、といった大まかなゴールも必要になる。</p>

<p>さらに、ここではなるべく粒度を細かくして互いのストーリーを独立させておくことで、作業がしやすくなり、見積もりも正確になる。</p>

<p>時には仕方なく大きい粒度のストーリーになることもあるが、それは計画段階では大きくしておいて、
実装に落としこむ際に複数に分かれることになる。</p>

<h4 id="section-18">プロジェクト開始の判断をする</h4>

<p>繰り返すが、プロジェクト開始時には、顧客は要求が定まっていないし、開発者もどの技術を使うのかが定まっていない。
またプロジェクトに割ける工数やコストも変化したり、ビジネス環境が変わってプロジェクト自体の見直しを迫られるかもしれない。
上記の情報が一切変動しないような特殊な状態でない限り、初期時に性格な見積もりをすることはできない。（逆に決まってたら、エンジニアは一切頭を使わないコーディングマシンとして働かされることになるだろう。）
まずはそこを自覚した上で、ざっくり「与えられた期間・コスト内に、必要最低限のシステム構築ができそうか？」だけチェックする。
決して多くをコミットしてはいけない。それは論理的に算出した数値ではなく希望的観測だから。</p>

<h4 id="section-19">実装するストーリーの重み付けをする。</h4>

<p>「工数」のような絶対的指標で見積もることは止めたほうがいい。そもそも出来ないし、人によって作業スピードが違うため。
そうではなく、相対的に「この作業はこの作業と同じくらい大変」「この作業ははるかに難しい」などのざっくりした区別をする。</p>

<h4 id="pdca">実際に作業をしてPDCAを回す。</h4>

<p>実際にストーリーの実装（システム開発）を行っていく。
ここでは小さくイテレーションを切って作業し、都度振り返って進捗を確認する。
イテレーションは１週間〜３週間が目安で、理由としては</p>

<ul>
  <li>作業が小さい粒度になっているため細かすぎることはない</li>
  <li>早めに顧客に見せてFBをもらうことで、期待値コントロールや、問題があった場合の即座の改善ができる。</li>
  <li>進捗を確認することで、スケジュール変更が必要な場合に早めに気づくことが出来る。</li>
</ul>

<h3 id="section-20">トラブル発生時には</h3>

<h4 id="section-21">スケジュールが間に合わなさそう</h4>

<p>イテレーションを重ね、チームの開発速度がわかったところで残タスクをみると明らかに間に合わなくなることが往々にして起きる。原因は</p>

<ul>
  <li>予想より速度が遅かった</li>
  <li>チームメンバーが抜けた。</li>
  <li>顧客の要望が変わった、増えた。</li>
</ul>

<p>こういった場合は、顧客に正直に伝え、期限を延ばすか機能を一部削いでもらうことで対応する他ない。</p>

<h2 id="section-22">まとめ</h2>
<p>アジャイルな開発は今のソフトウェアが複雑化した次代に必須なんだろうけど、それをするには技術やアジャイルな開発に抵抗のない顧客が居ることが大前提だなと思った。
（わかってない人が顧客だと、無理なスケジュールを押し付けてきたり、計画変更を拒絶したりしそう。そのくせ要求をきちんと伝えてくれなくて後から揉めそう。）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アジャイル開発の教科書]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/30/textbook-of-agile-development/"/>
    <updated>2014-06-30T00:07:54+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/30/textbook-of-agile-development</id>
    <content type="html"><![CDATA[<p>Agileについての基礎を学びたかったので。</p>

<p>技術書みたいなものなので、いつものBookReviewとは違いますが。</p>

<!--more-->

<p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797371285/jitabatashiba-22/" target="_blank"><img src="http://ecx.images-amazon.com/images/I/41BWXiUC4NL.jpg" width="354" height="500" alt="わかりやすいアジャイル開発の教科書" title="わかりやすいアジャイル開発の教科書" /></a></p>

<h3 id="section">要望を把握できているのか？</h3>

<p>要望は変化する。受け入れきれない。
始めに来る要望が正しいことも、それを開発者が正しく理解できることも多くないので、柔軟にしておく（初めに全て決めない）。
※きちんと要件定義できて突き詰めきれる規模なら問題はない。</p>

<p>アジャイルのデメリットは多少効率が落ちることと、お客様の言うとおりにせずに考えなきゃいけないので難しいこと。</p>

<p>お客様と主従関係になるのではなく、対等な関係として位置する。</p>

<p>ドキュメントを書くよりも動くものを見せていくほうが理解が早い。
コードを読んだほうが人にも誤解なく伝わる。</p>

<h3 id="section-1">分割して分担する</h3>

<p>機能を細かく分けて組み合わせていく。</p>

<p>一気通貫で組み上げない分効率が悪くなるかもしれないが、
変更・再利用しやすく、コードの一部だけ抜き出しても理解できる。
（上から下まで通すロジックを書くと、脳内OoMするのでは？）</p>

<p>そのためにはペアプロやコードレビューをもっと徹底的に。</p>

<h3 id="section-2">お客様に見せることですりあわせられる。</h3>

<p>顧客に提供するのは価値。
そのためにはどういった仕様にすればいいのか。
（SaaS化する、キチンと説明した上で製品を納品する）</p>

<p>出来上がってみないと顧客の要望を把握しきれなかったりするので、
Mockや完成品を見せて、ズレていたら説明・理解・修正を繰り返していく必要がある。</p>

<p>（私見ですが、パラダイムシフトや知識不足にはモノを見せるのが早かったりするのではないでしょうか？
いくら説明しても抽象的な部分は理解しきれないと思うので。）</p>

<h3 id="section-3">変化を抱擁せよ</h3>

<p>その時の最大を求めて変化していきたい。</p>

<p>変更は改善を意味する。変化に強い設計を。
そのためにはソフトウェアを柔軟に。
技術・ニーズの変化にも対応しやすい。</p>

<h3 id="section-4">タイムボックス・スプリント</h3>

<p>期間を短く切って、その期間内に完結する修正を入れていく。</p>

<p>半ば強制的に設計が分割される。</p>

<p>短い期間でPDCAを回すことで、改善のスピードが向上する。</p>

<p>タイムボックス完了時には、実働するソフトウェアを組み上げている。
それを顧客に見せつつ、ズレがあれば次に即座に修正を加えていく。</p>

<h3 id="ci">CI</h3>

<p>早くフィードバックしたほうがコストが低いと言われている。</p>

<p>ビルドだけでなくてテストやデプロイまで回したい。</p>

<h3 id="yagni">シンプルに yagniに</h3>

<p>YAGNI（You ain’t gonna need it）</p>

<p>その時に必要な最小構成で組み上げていくことで、結果として変更に強くなる。</p>

<p>同じことは二度しない。拡張しにくくなるから。</p>

<h3 id="section-5">振り返る</h3>

<p>PDCAを回さないと何が悪かったのかわからない。
指標をおいてそれをクリアしていくこと</p>

<h3 id="section-6">見える化</h3>

<p>データが見えることとと見える化することは違う。
次の行動を誘発するのが見える化。
データを羅列するだけでは意味がない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redmine&Agile]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/15/redmine-memo/"/>
    <updated>2014-06-15T11:48:34+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/15/redmine-memo</id>
    <content type="html"><![CDATA[<!--more-->

<p>redmine &amp; カンバン</p>

<p>アジャイルの単語の定義と、での認識</p>

<p>アジャイル開発・・・短い周期で動く製品を組み上げていくスタイル。顧客の優先度順に機能を作れて、認識に齟齬があればすぐに修正できる。</p>

<p>ウォーターフォール・・・現行の開発。期間と顧客の要求を定義して、それを守るように進める。
IT土方の時代なら上手く機能しそうだけど。。。</p>

<p>ストーリー・・・顧客の価値ベースで意味のある単位。顧客からの要望・不具合報告・新機能の追加要件などなどが当てはまる。粒度は作業量で揃えたいが、あくまで顧客のメリットベース。</p>

<p>見積もり・・・工数で書くと人によって異なるので、ポイントなど相対的な指標で書き込む。数字が大きいと厳密性がなくなるので、粒度は荒くても十分</p>

<p>PDCAを多く回す。
そのためには</p>

<ul>
  <li>定量的なデータを見積もり検証する</li>
  <li>サイクルを多く回す</li>
</ul>

<p>コンサルやマネージャーに進捗を確認してもらうには、
あるいは、開発者のモチベーションを上げるには。</p>

<ul>
  <li>バーンダウン</li>
  <li>カンバン</li>
  <li>朝会議</li>
</ul>

<p>redmineのPlugin ALMiniumでコードの管理やスプリントもできる。</p>

<ul>
  <li>普段はgitlab</li>
  <li>Redmineでのプラグインはサポートしないが便利くらいにしたい。</li>
</ul>

<p>http://qiita.com/cock1doodledoo/items/39e6cea44a377207eaff</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Agileメモ]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/15/agile-memo/"/>
    <updated>2014-06-15T11:17:47+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/15/agile-memo</id>
    <content type="html"><![CDATA[<p>Agileとは何なのか？なぜこんなに評価されてるのか？</p>

<!--more-->

<p>対比としてウォーターフォール型が語られるので、それと比較します。</p>

<h3 id="section">目的</h3>

<h4 id="section-1">ウォーターフォール</h4>

<p>スケジュールを守ること。段取りをかっちり固めること</p>

<h4 id="agile">Agile</h4>

<p>顧客の価値の最大化</p>

<h3 id="section-2">特徴</h3>

<h4 id="section-3">ウォーターフォール</h4>

<ul>
  <li>設計をかっちり固める</li>
  <li>長期的に行う</li>
  <li>途中でミスると手戻りがすごく大きくなる</li>
  <li>仕様書が大事</li>
  <li>契約に従う</li>
  <li>管理が楽</li>
  <li>開発者はただの実装者になる</li>
  <li>顧客は自分の欲しいものが明確に伝えられる</li>
</ul>

<h4 id="agile-1">Agile</h4>

<ul>
  <li>設計はあとから変化するかもしれない</li>
  <li>短いスパンで切っていく</li>
  <li>ミスを早めに見つけて対応できる</li>
  <li>動くシステム（≒Mock）が大事</li>
  <li>仕様より顧客との協調を優先する</li>
  <li>バランスを取るのが難しい</li>
  <li>開発者も全体の流れを考える必要がある。</li>
  <li>顧客も製品を見るまではっきりしていない</li>
</ul>

<h3 id="section-4">背景</h3>

<p>では、なぜAgileが盛んになったのか。
僕が考える理由は以下です。</p>

<h4 id="section-5">アプリケーションの複雑化</h4>

<p>電卓レベルではなく複雑なシステムになるにつれて、顧客がアプリケーションの全体像や意義を全て把握できない規模になってきた。</p>

<p>同時に、開発の規模も増加してきて、長期計画を立てられるレベルでなくなってきた。</p>

<h4 id="it">IT環境の変化の激しさ</h4>

<p>インターネットの普及により、技術の進歩や他社の変化が激しくなってきたため、１年２年前では考えられない要因が多数入ってくるから。</p>

<h4 id="section-6">設計の洗練</h4>

<p>手続き型からオブジェクト、関数型へ変化していき、
初めにきっちり仕様を固めなくても変化に強い設計が行えるようになった。
オブジェクト指向の色々な原則も小さく柔軟に、というところから来ている。</p>
]]></content>
  </entry>
  
</feed>
