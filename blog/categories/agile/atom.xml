<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Agile | ジタバタしばた]]></title>
  <link href="http://uryyyyyyy.shake-freek.com/blog/categories/agile/atom.xml" rel="self"/>
  <link href="http://uryyyyyyy.shake-freek.com/"/>
  <updated>2015-11-20T23:51:15+09:00</updated>
  <id>http://uryyyyyyy.shake-freek.com/</id>
  <author>
    <name><![CDATA[しばたこ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[アジャイルサムライ]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2015/11/20/agile-samurai/"/>
    <updated>2015-11-20T23:47:36+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2015/11/20/agile-samurai</id>
    <content type="html"><![CDATA[<p>ソフトウェア開発において、アジャイル開発は王道（というかソフトウェア以外ではしたくても出来なかった手法）だと理解しています。
その手法について良くまとめられていると評判だった本書を読んで、個人的なポイントをメモしてみました。</p>

<!--more-->

<p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4274068560/jitabatashiba-22/" target="_blank"><img src="http://ecx.images-amazon.com/images/I/51b4P511wTL.jpg" width="350" height="500" alt="アジャイルサムライ−達人開発者への道−" title="アジャイルサムライ−達人開発者への道−" /></a></p>

<h2 id="section">概要</h2>

<p>一番大切なことは、常に顧客に価値をもたらすこと。つまりは定期的（一週間毎くらい）に、動く（テスト済みの）ソフトウェアを提供すること。
仕様書や計画書はその補完にしか過ぎない。実際にメリットを提供できて初めて責任を果たしたと言える。</p>

<p>そのために以下を心がける。</p>

<p>・大きな問題、ストーリーは小さく分割する。
→大きすぎると期間・仕様が見積もれない。いざ完成してからズレていたと発覚しては遅い。
・本当にメリットのあるもののみに注力し、他は忘れる。
→システムのうち、お客様にメリットを提供している機能はごく一部だから。
・常に動く状態にする。
→いつでもテスト可能なようにすることで、仕様を満たしていることを保証する。
・フィードバック、実挙動の確認を求める。
→仕様を知っていてお金を出すのはお客様なのだから。
・必要とあれば方針を変える
→定期的に（イテレーション毎に）顧客と話して機能の優先度、仕様を確認する。なぜなら、仕様もスケジュールも常に流動するから。
・説明責任を果たす。
→毎週成果を求められ、また顧客と共に次の計画を考えるため、全てを説明して納得してもらわなければならない。
しかし、ウォーターフォール型で最後に神頼みをするよりマシかもしれない。</p>

<h3 id="agileagile">なぜagileか。Agileとは何か</h3>

<p>Agileとは、ウォーターフォールと比較して、最初に要件を固めすぎずに都度対応していく方法のこと。
これによって、
・早いうちからユーザーにシステムを使ってもらうことで価値を提供できる。
・着実に目に見える形で進捗を重ねることができる。
・急なスケジュール・仕様変更に強くなる。</p>

<p>特に最後の部分で、ソフトウェア開発においては以下の経験則が成り立つことを前提としている。
・プロジェクトの開始時点に全ての要求をヒアリングできない。
・要求は必ず後で変更される。
・納期や資金に比べて、やるべきことは常に多すぎる</p>

<p>ただ、これはハードウェアの世界でもおそらく起きているものの、顧客側が仕方ないと理解しているため問題とならないのではと個人的に推測する。</p>

<h2 id="section-1">登場人物</h2>

<h3 id="section-2">要件は誰が決める？</h3>

<p>ソフトウェアの要件とは、どんな価値を提供するかに当たる。つまりは顧客（あるいはそのドメインの専門家）しか知ることはない。
どの機能がどのくらいの優先度で必要なのか、もしQCD全てをこなすことが難しければ、どの部分で妥協できるのか、などを決める。
ということは、ソフトウェア開発においては顧客も積極的に参加しなくてはいけない。常に要件を発言し、システムのフィードバックを行うことが必要だ。</p>

<p>もしこれらの作業を引き受けてくれる人がいない場合は、まだそのプロジェクト自体の優先度が高くないのかもしれない。他の事に目を向けよう。</p>

<h3 id="section-3">誰が作る？</h3>

<p>開発チームは、テスター、プログラマ、デザイナ、アナリストなどの全ての役割を誰かが担うことになる。
それぞれの役割は明確に区切られているものではないため、スピードを求めると同じ人が複数の責務を担うことが重要になる。要するに、ある程度の専門性を持ちつつ、必要に応じて他の分野の作業も担えるゼネラリストが求められる。</p>

<p>代表的な役割を順番に見ていく。</p>

<h4 id="section-4">アナリスト</h4>

<p>顧客と開発チームの橋渡しを行う。</p>

<p>・顧客の要求をヒアリングしてシステムの要件に落としこむ。
・優先度を定義する。
・システムの完了を確認するためのシナリオを用意する。</p>

<p>などを担う。</p>

<h4 id="section-5">プログラマ</h4>

<p>・要件のコストを見積もる。
・要件を機械語に翻訳する。
・技術選定を行う。
・実装のゴールを定義するテストを作成する。</p>

<h4 id="section-6">テスター</h4>

<p>・非機能要件（性能、セキュリティ、コスト）のテスト設計を行う。
・テスト作成を手伝う。
・テストを自動化し常に回せるようにする。</p>

<h4 id="section-7">プロジェクトマネージャ</h4>

<p>・プロジェクトの様子（進捗・タスク）を確認し共有する。
・プロジェクトの環境を整える（開発環境・工数確保）</p>

<h4 id="section-8">デザイナ</h4>

<p>・よりユーザーが使いやすいUIを考案、実装する。
・ユーザーのニーズを深堀りしてシステムに落としこむ。</p>

<h4 id="section-9">ステークホルダーは他も居る</h4>

<p>組織の中でプロジェクトを行っている場合、利害関係者はプロジェクトメンバーだけでない。品質管理の部門やセキュリティ、インフラ部門なども関わるかもしれない。
メンバーだけで突き進むのではなく、彼らのことも気に留めて、時には情報共有をしておく必要がある。</p>

<h2 id="section-10">プロジェクトの進め方</h2>

<h3 id="section-11">目指す方向を共有する</h3>

<p>インセプションデッキと呼ばれるツールを使った例を挙げる。</p>

<h4 id="section-12">チームの目的は何か？</h4>

<p>まずはチームとして集まった目的、作るシステムの概要を確認する。このとき、2,3センテンスでまとめられるレベルまで落としこみ、かつそれが魅力的（顧客がお金を払ってでも欲しがる）であるかどうかを確認する。
もしそこまで落とし込めなければプロジェクトを止めることも有り。</p>

<h4 id="section-13">何をやらないか？</h4>

<p>プロジェクトメンバー、お客様への情報共有としてわかりやすい例。これによって、本当にフォーカスする問題が浮かび上がる。
ただし、まだどうするか決まってないことはやらないことではなく未定とする。</p>

<h4 id="section-14">期間・予算はどのくらいか？実現可能なラインか？</h4>

<p>大まかな要求が決まったら、実現プランを考えていく。（例えばWebアプリを作るとか、データベースはこんな感じにするとか）
ここでは具体的なものではなく、チームや顧客への大まかな道筋の共有ができれば良い。どうせ後で要求も実装も変わってくるから。</p>

<p>また、プロジェクトを進める前に考えられるリスクを先に洗い出しておき、大まかな対策を考える。ここで案を考えておくことで、プロジェクトがひっくり返るリスクを減らしておくことに繋がる。（リスクの起こる確率が大きく、かつ対応不可能であれば、それはプロジェクト自体の筋が悪いのかもしれない。）
もちろん、天災などどうしようもないものは考えるだけ無駄だけど。</p>

<p>そうしてプロジェクトを進めても問題なさそうと推測できるようになったら、最後に大まかにスケジュールとコスト感を見積もる。これはコミットではないが、顧客にとって必要な情報だからだ。
このとき、プロジェクトの規模が大きすぎるときは最長半年くらいで小ゴールを引いておく。そうしないと見積りできなり、顧客もGoの判断を下すことのリスクが大きすぎるから。</p>

<h4 id="section-15">何を妥協できるか？</h4>

<p>往々にしてプロジェクトはスケジュールよりも悪い方向にズレる。
その時になってから妥協案を考えると、顧客に不快感を与えてしまったり、急なことで決断が出来なくなる恐れがある。
そこで事前に妥協できるポイントを聞いておく。</p>

<p>フィーチャのいくつかを削るとか、期日を延ばすとかが典型的な例。
なぜなら、
・予算は調整が難しく、またソフトウェアにおいてはお金は万能ではないから。
・品質は、下げたからといって機能が追加できるものではなく、むしろお互いに余計な時間を取られることに繋がりかねないから。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アジャイル開発の教科書]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/30/textbook-of-agile-development/"/>
    <updated>2014-06-30T00:07:54+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/30/textbook-of-agile-development</id>
    <content type="html"><![CDATA[<p>Agileについての基礎を学びたかったので。</p>

<p>技術書みたいなものなので、いつものBookReviewとは違いますが。</p>

<!--more-->

<p><a href="http://www.amazon.co.jp/exec/obidos/ASIN/4797371285/jitabatashiba-22/" target="_blank"><img src="http://ecx.images-amazon.com/images/I/41BWXiUC4NL.jpg" width="354" height="500" alt="わかりやすいアジャイル開発の教科書" title="わかりやすいアジャイル開発の教科書" /></a></p>

<h3 id="section">要望を把握できているのか？</h3>

<p>要望は変化する。受け入れきれない。
始めに来る要望が正しいことも、それを開発者が正しく理解できることも多くないので、柔軟にしておく（初めに全て決めない）。
※きちんと要件定義できて突き詰めきれる規模なら問題はない。</p>

<p>アジャイルのデメリットは多少効率が落ちることと、お客様の言うとおりにせずに考えなきゃいけないので難しいこと。</p>

<p>お客様と主従関係になるのではなく、対等な関係として位置する。</p>

<p>ドキュメントを書くよりも動くものを見せていくほうが理解が早い。
コードを読んだほうが人にも誤解なく伝わる。</p>

<h3 id="section-1">分割して分担する</h3>

<p>機能を細かく分けて組み合わせていく。</p>

<p>一気通貫で組み上げない分効率が悪くなるかもしれないが、
変更・再利用しやすく、コードの一部だけ抜き出しても理解できる。
（上から下まで通すロジックを書くと、脳内OoMするのでは？）</p>

<p>そのためにはペアプロやコードレビューをもっと徹底的に。</p>

<h3 id="section-2">お客様に見せることですりあわせられる。</h3>

<p>顧客に提供するのは価値。
そのためにはどういった仕様にすればいいのか。
（SaaS化する、キチンと説明した上で製品を納品する）</p>

<p>出来上がってみないと顧客の要望を把握しきれなかったりするので、
Mockや完成品を見せて、ズレていたら説明・理解・修正を繰り返していく必要がある。</p>

<p>（私見ですが、パラダイムシフトや知識不足にはモノを見せるのが早かったりするのではないでしょうか？
いくら説明しても抽象的な部分は理解しきれないと思うので。）</p>

<h3 id="section-3">変化を抱擁せよ</h3>

<p>その時の最大を求めて変化していきたい。</p>

<p>変更は改善を意味する。変化に強い設計を。
そのためにはソフトウェアを柔軟に。
技術・ニーズの変化にも対応しやすい。</p>

<h3 id="section-4">タイムボックス・スプリント</h3>

<p>期間を短く切って、その期間内に完結する修正を入れていく。</p>

<p>半ば強制的に設計が分割される。</p>

<p>短い期間でPDCAを回すことで、改善のスピードが向上する。</p>

<p>タイムボックス完了時には、実働するソフトウェアを組み上げている。
それを顧客に見せつつ、ズレがあれば次に即座に修正を加えていく。</p>

<h3 id="ci">CI</h3>

<p>早くフィードバックしたほうがコストが低いと言われている。</p>

<p>ビルドだけでなくてテストやデプロイまで回したい。</p>

<h3 id="yagni">シンプルに yagniに</h3>

<p>YAGNI（You ain’t gonna need it）</p>

<p>その時に必要な最小構成で組み上げていくことで、結果として変更に強くなる。</p>

<p>同じことは二度しない。拡張しにくくなるから。</p>

<h3 id="section-5">振り返る</h3>

<p>PDCAを回さないと何が悪かったのかわからない。
指標をおいてそれをクリアしていくこと</p>

<h3 id="section-6">見える化</h3>

<p>データが見えることとと見える化することは違う。
次の行動を誘発するのが見える化。
データを羅列するだけでは意味がない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redmine&Agile]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/15/redmine-memo/"/>
    <updated>2014-06-15T11:48:34+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/15/redmine-memo</id>
    <content type="html"><![CDATA[<!--more-->

<p>redmine &amp; カンバン</p>

<p>アジャイルの単語の定義と、での認識</p>

<p>アジャイル開発・・・短い周期で動く製品を組み上げていくスタイル。顧客の優先度順に機能を作れて、認識に齟齬があればすぐに修正できる。</p>

<p>ウォーターフォール・・・現行の開発。期間と顧客の要求を定義して、それを守るように進める。
IT土方の時代なら上手く機能しそうだけど。。。</p>

<p>ストーリー・・・顧客の価値ベースで意味のある単位。顧客からの要望・不具合報告・新機能の追加要件などなどが当てはまる。粒度は作業量で揃えたいが、あくまで顧客のメリットベース。</p>

<p>見積もり・・・工数で書くと人によって異なるので、ポイントなど相対的な指標で書き込む。数字が大きいと厳密性がなくなるので、粒度は荒くても十分</p>

<p>PDCAを多く回す。
そのためには</p>

<ul>
  <li>定量的なデータを見積もり検証する</li>
  <li>サイクルを多く回す</li>
</ul>

<p>コンサルやマネージャーに進捗を確認してもらうには、
あるいは、開発者のモチベーションを上げるには。</p>

<ul>
  <li>バーンダウン</li>
  <li>カンバン</li>
  <li>朝会議</li>
</ul>

<p>redmineのPlugin ALMiniumでコードの管理やスプリントもできる。</p>

<ul>
  <li>普段はgitlab</li>
  <li>Redmineでのプラグインはサポートしないが便利くらいにしたい。</li>
</ul>

<p>http://qiita.com/cock1doodledoo/items/39e6cea44a377207eaff</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Agileメモ]]></title>
    <link href="http://uryyyyyyy.shake-freek.com/blog/2014/06/15/agile-memo/"/>
    <updated>2014-06-15T11:17:47+09:00</updated>
    <id>http://uryyyyyyy.shake-freek.com/blog/2014/06/15/agile-memo</id>
    <content type="html"><![CDATA[<p>Agileとは何なのか？なぜこんなに評価されてるのか？</p>

<!--more-->

<p>対比としてウォーターフォール型が語られるので、それと比較します。</p>

<h3 id="section">目的</h3>

<h4 id="section-1">ウォーターフォール</h4>

<p>スケジュールを守ること。段取りをかっちり固めること</p>

<h4 id="agile">Agile</h4>

<p>顧客の価値の最大化</p>

<h3 id="section-2">特徴</h3>

<h4 id="section-3">ウォーターフォール</h4>

<ul>
  <li>設計をかっちり固める</li>
  <li>長期的に行う</li>
  <li>途中でミスると手戻りがすごく大きくなる</li>
  <li>仕様書が大事</li>
  <li>契約に従う</li>
  <li>管理が楽</li>
  <li>開発者はただの実装者になる</li>
  <li>顧客は自分の欲しいものが明確に伝えられる</li>
</ul>

<h4 id="agile-1">Agile</h4>

<ul>
  <li>設計はあとから変化するかもしれない</li>
  <li>短いスパンで切っていく</li>
  <li>ミスを早めに見つけて対応できる</li>
  <li>動くシステム（≒Mock）が大事</li>
  <li>仕様より顧客との協調を優先する</li>
  <li>バランスを取るのが難しい</li>
  <li>開発者も全体の流れを考える必要がある。</li>
  <li>顧客も製品を見るまではっきりしていない</li>
</ul>

<h3 id="section-4">背景</h3>

<p>では、なぜAgileが盛んになったのか。
僕が考える理由は以下です。</p>

<h4 id="section-5">アプリケーションの複雑化</h4>

<p>電卓レベルではなく複雑なシステムになるにつれて、顧客がアプリケーションの全体像や意義を全て把握できない規模になってきた。</p>

<p>同時に、開発の規模も増加してきて、長期計画を立てられるレベルでなくなってきた。</p>

<h4 id="it">IT環境の変化の激しさ</h4>

<p>インターネットの普及により、技術の進歩や他社の変化が激しくなってきたため、１年２年前では考えられない要因が多数入ってくるから。</p>

<h4 id="section-6">設計の洗練</h4>

<p>手続き型からオブジェクト、関数型へ変化していき、
初めにきっちり仕様を固めなくても変化に強い設計が行えるようになった。
オブジェクト指向の色々な原則も小さく柔軟に、というところから来ている。</p>
]]></content>
  </entry>
  
</feed>
